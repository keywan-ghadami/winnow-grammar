# Feature Requests for `syn-grammar`

This document outlines feature requests and issues encountered while building a TOML parser and safety-critical tests using `winnow-grammar` (which acts as a backend for `syn-grammar-model`).

## 1. Support Arguments for Built-in Rules

**Context:**
We attempted to implement a `take_until` built-in to handle comments efficiently. We added it to the `get_builtins()` list in the backend.

**Issue:**
`syn-grammar-model`'s validator explicitly forbids arguments for rules defined as built-ins.
```rust
// In validator.rs
if is_builtin && !args.is_empty() {
    return Err(syn::Error::new(..., "Built-in rule '...' does not accept arguments."));
}
```

**Request:**
Allow built-ins to accept arguments.
*   **Option A:** Relax validation to allow any number of arguments for built-ins (deferring checking to the backend).
*   **Option B:** Update `BuiltIn` struct to include an optional arity or signature definition.

**Example Use Case:**
```rust
rule comment -> () = "#" take_until("\n") -> { () }
```

## 2. Support for "Extern" or Imported Rules

**Context:**
We wanted to define a complex parser logic (like whitespace handling or specific token consumption) in standard Rust functions and use them inside the grammar. While the `grammar!` macro allows `use` statements, the validator flags any rule name not defined in the `grammar` block as "Undefined rule", even if it is imported.

**Issue:**
Users cannot easily mix generated rules with handwritten parsers without hacking the backend's "built-in" list.

**Request:**
Add syntax to declare external rules that should skip existence/definition validation.

**Proposed Syntax:**
```rust
grammar MyGrammar {
    use super::my_custom_parser;
    
    // Tell syn-grammar that this exists externally
    extern rule my_custom_parser; 

    rule main -> () = my_custom_parser -> { () }
}
```

## 3. Syntax for `Not` (`!`) and `Peek` (`&`) Operators

**Context:**
The `syn-grammar-model` AST (`ModelPattern`) contains `Not` and `Peek` variants. However, attempting to use standard EBNF/PEG syntax fails at the parsing stage.

**Issue:**
Input: `! line_ending`
Error: `error: expected ident`

**Request:**
Implement parsing support for negation and lookahead.

**Proposed Syntax:**
```rust
rule no_newline -> char = !"\n" c:any -> { c }
// OR
rule no_newline -> char = not("\n") c:any -> { c }
```

## 4. Resolve Parsing Ambiguity: `ident (group)` vs `call(args)`

**Context:**
In EBNF, whitespace is significant for separation, but `syn-grammar` seems to interpret an identifier followed by a parenthesized group as a function call, regardless of whitespace.

**Issue:**
```rust
rule ws -> () = 
    multispace0 (comment multispace0)* -> { () }
```
This fails with: `Rule 'multispace0' expects 0 argument(s), but got 1.`
The parser interprets `multispace0 ( ... )` as `multispace0(arg)`.

**Workaround used:**
We had to wrap the identifier in a group to force it to be treated as a pattern unit:
```rust
rule ws -> () = 
    (multispace0) (comment multispace0)* -> { () }
```

**Request:**
Improve the parser to distinguish between sequence and calls, potentially by requiring no whitespace for calls (if possible in `syn`) or providing a clearer sequence structure. At a minimum, this behavior should be documented.

## 5. `fail` Built-in

**Context:**
For error recovery and control flow (like `recover(fail, sync)`), a parser that always fails is very useful.

**Request:**
Add `fail` to the standard set of built-ins or allow the backend to define it easily without it being flagged as undefined. (Solved partially by Request #1 and #2).

## 6. Type Inference Improvements

**Context:**
When using combinators like `recover` or `alt` generated by the backend, Rust often fails to infer types if the return values are complex (e.g., `Result<String, _>` vs `Result<(), _>`).

**Request:**
While this is largely a backend codegen issue, `syn-grammar` could potentially allow explicit type annotation on sub-patterns or variable bindings to help the backend generate fully typed code.
```rust
// Hypothetical syntax
rule example -> () = x:(i32: u32) -> { ... }
```
